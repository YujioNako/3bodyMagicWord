<!DOCTYPE html>
<html>
<head>
    <title>æ’æ˜Ÿ3Då¯è§†åŒ–</title>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; }
        #container { display: flex; height: 100vh; width: 100vw; }
        #three-container,#css3d-container { position: fixed; right: 0; }
        #css3d-container { pointer-events: none!important; }
        #controls { 
            position: relative;
            right: 0;
            width: 350px;
            padding: 20px;
            background: #f0f0f0;
            overflow-y: auto;
        }
        .canvas2d { 
            width: 300px; 
            height: 300px; 
            margin: 10px 0;
            border: 1px solid #ccc;
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin: 5px 0; }
    .csslabel {
      background: rgba(255, 255, 255, 0);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: Arial;
      font-size: 14px;
      color: #ddd;
      pointer-events: none!important;
      white-space: nowrap;
    }
    </style>
</head>
<body>
    <div id="container">
        <div id="three-container"></div>
        <div id="css3d-container"></div>
        <div id="controls">
            <div class="control-group">
                <h3>æ‘„åƒæœºæ§åˆ¶</h3>
                <div class="control">
                    <label>X: <input type="number" id="posX" step="1"></label>
                    <label>Y: <input type="number" id="posY" step="1" value="0"></label>
                    <label>Z: <input type="number" id="posZ" step="1" value="0"></label>
                    <label>FOV: <input type="number" id="Fov" step="1" value="90"></label>
                    <label>DistLimit: <input type="number" id="Dist" step="1" value="4"></label>
                </div>
                <h3>ä¸­å¿ƒç‚¹æ§åˆ¶</h3>
                <div class="control">
                    <label>X: <input type="number" id="cenX" step="1" value="0"></label>
                    <label>Y: <input type="number" id="cenY" step="1" value="0"></label>
                    <label>Z: <input type="number" id="cenZ" step="1" value="0"></label>
                </div>
                <button onclick="resetCamera()">é‡ç½®è§†è§’</button>
            </div>
            
            <h3>æŠ•å½±è§†å›¾</h3>
            <canvas id="yz-projection" width="300" height="300" class="canvas2d"></canvas>
            <canvas id="xz-projection" width="300" height="300" class="canvas2d"></canvas>
            <canvas id="xy-projection" width="300" height="300" class="canvas2d"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script>
        let scene, camera, renderer, controls, cssScene, cssRenderer;

        let stars = [];
        let data = [];
        let rows = null;
        let ranges = {
            x: { min: 0, max: 0 },
            y: { min: 0, max: 0 },
            z: { min: 0, max: 0 }
        };
        // å…‰è°±é¢œè‰²æ˜ å°„
        const SPECTRAL_COLOR = {
            'O':'#9bb0ff', 'B':'#aabfff', 'A':'#cad7ff',
            'F':'#f8f7ff', 'G':'#ffe169', 'K':'#ffd27a',
            'M':'#ffb347', 'default':'#fff'
        };
        let DIST_LIMIT = 4

        // åˆå§‹åŒ–
        async function init() {
            await loadCSVData();
            setupThreeScene();
            setupProjectionCanvases();
            setupEventListeners();
            animate();
        }

        // CSVæ•°æ®åŠ è½½
        async function loadCSVData() {
            if (!rows) {
                // ä½¿ç”¨ fetch è·å–.gzå‹ç¼©æ–‡ä»¶
                const response = await fetch('hygdata_v32.csv.gz'); // æ–‡ä»¶åæ”¹ä¸º.gzæ ¼å¼
                const arrayBuffer = await response.arrayBuffer(); // è·å–äºŒè¿›åˆ¶æ•°æ®

                // è§£å‹gzipå†…å®¹ï¼ˆéœ€è¦å¼•å…¥pakoåº“ï¼‰
                const decompressedText = pako.inflate(arrayBuffer, { to: 'string' });

                // å¤„ç†CSVæ•°æ®
                rows = decompressedText.split('\n').slice(1);
            }
            
            data = rows.map(row => {
                const cols = row.split(',');
                return {
                    x: parseFloat(cols[17]) - parseFloat(document.getElementById('cenX').value||0),
                    y: parseFloat(cols[18]) - parseFloat(document.getElementById('cenY').value||0),
                    z: parseFloat(cols[19]) - parseFloat(document.getElementById('cenZ').value||0),
                    mag: parseFloat(cols[13]),
                    name: cols[6],
                    spect: cols[15]?.[0] ?? 'default',
                    dist: parseFloat(cols[9])
                };
            }).filter(d => !isNaN(d.x)&&Math.abs(d.x)<=DIST_LIMIT&&Math.abs(d.y)<=DIST_LIMIT&&Math.abs(d.z)<=DIST_LIMIT);


            // è®¡ç®—åæ ‡èŒƒå›´
            ranges.x.min = Math.min(...data.map(d => d.x));
            ranges.x.max = Math.max(...data.map(d => d.x));
            ranges.y.min = Math.min(...data.map(d => d.y));
            ranges.y.max = Math.max(...data.map(d => d.y));
            ranges.z.min = Math.min(...data.map(d => d.z));
            ranges.z.max = Math.max(...data.map(d => d.z));
        }

        function calculateDistance(fovDegrees, DIST_LIMIT) {
            // å°†FOVä»åº¦æ•°è½¬ä¸ºå¼§åº¦
            const fovRadians = (fovDegrees * Math.PI) / 180;
    
            // è®¡ç®—æ‰€éœ€è·ç¦»ï¼šd = (DIST_LIMIT) / tan(fov/2)
            const requiredDistance = DIST_LIMIT / Math.tan(fovRadians / 2);
    
            return requiredDistance;
        }


        // 3Dåœºæ™¯è®¾ç½®
        function setupThreeScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(90, 1, 0.1, 10000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            
            // åˆå§‹åŒ–æ¸²æŸ“å™¨
            renderer.setSize(Math.min(window.innerWidth, window.innerHeight), Math.min(window.innerWidth, window.innerHeight));
            document.getElementById('three-container').innerHTML = ''; // æ¸…ç©ºå®¹å™¨
            document.getElementById('three-container').appendChild(renderer.domElement);


// åˆå§‹åŒ– CSS3DRenderer åœºæ™¯
cssScene = new THREE.Scene();
cssRenderer = new THREE.CSS3DRenderer({ antialias: true });
cssRenderer.setSize(Math.min(window.innerWidth, window.innerHeight), Math.min(window.innerWidth, window.innerHeight));
//cssRenderer.domElement.style.position = 'fixed';
//cssRenderer.domElement.style.top = '0';
cssRenderer.domElement.style.pointerEvents = 'none';
document.getElementById('css3d-container').innerHTML = ''; // æ¸…ç©ºå®¹å™¨
document.getElementById('css3d-container').appendChild(cssRenderer.domElement);

// åˆ›å»ºçˆ¶å®¹å™¨åŒæ­¥ä½ç½®
const parent = new THREE.Group();
scene.add(parent);

            // åˆ›å»ºå‡ ä½•ä½“ï¼ˆè‡ªåŠ¨ä¸­å¿ƒåœ¨åŸç‚¹ï¼‰
            const geometry_square = new THREE.BoxGeometry(
            2 * DIST_LIMIT,
            2 * DIST_LIMIT,
            2 * DIST_LIMIT
            );

            // åˆ›å»ºè¾¹çº¿å‡ ä½•ä½“
            const edges = new THREE.EdgesGeometry(geometry_square);

            // åˆ›å»ºçº¿æ¡†æè´¨
            const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ff00,
            linewidth: DIST_LIMIT/1000
            });

            // ç»„åˆæˆçº¿æ¡†å¯¹è±¡
            const cubeFrame = new THREE.LineSegments(edges, lineMaterial);

            // æ·»åŠ åˆ°åœºæ™¯
            scene.add(cubeFrame);

            // åˆ›å»ºæ˜Ÿç¾¤
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(data.length * 3);
            data.forEach((d, i) => {
                positions[i*3] = d.x;
                positions[i*3+1] = d.y;
                positions[i*3+2] = d.z;
            });

            // åˆ›å»ºæ˜Ÿç¾¤æè´¨è¡¨ä¸æ˜Ÿç¾¤åç§°è¡¨
            const materialIndices = new Uint8Array(data.length);
            const nameIndices = [];
            data.forEach((d, i) => {
                materialIndices[i] = Object.keys(SPECTRAL_COLOR).indexOf(d.spect)==-1?7:Object.keys(SPECTRAL_COLOR).indexOf(d.spect);
                nameIndices.push(d.name=="\"\""?'':d.name);
            });

            const groups = [[], [], [], [], [], [], [], []]; // å­˜å‚¨æ¯ä¸ªæè´¨ç»„çš„åæ ‡
            const names = [[], [], [], [], [], [], [], []];
            for (let i = 0; i < positions.length / 3; i++) {
              const index = materialIndices[i];
              const x = positions[i * 3];
              const y = positions[i * 3 + 1];
              const z = positions[i * 3 + 2];
              const name = nameIndices[i];
              groups[index].push(x, y, z);
              names[index].push(name);
            }

            // ä¸ºæ¯ä¸ªæè´¨ç»„åˆ›å»º Geometry
            const geometries = groups.map(points => {
              const geometry = new THREE.BufferGeometry();
              geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
              return geometry;
            });

            function createCircularMaterial(options = {}) {
              const {
                color = '#ff0000',  // é»˜è®¤çº¢è‰²
                textureSize = 256,  // çº¹ç†å°ºå¯¸
                materialOptions = {} // å…¶ä»–æè´¨é…ç½®
              } = options;

              // åˆ›å»ºåœ†å½¢çº¹ç†
              const canvas = document.createElement('canvas');
              canvas.width = textureSize;
              canvas.height = textureSize;
              const ctx = canvas.getContext('2d');
  
              // åŠ¨æ€è®¡ç®—åœ†å½¢å‚æ•°
              const centerX = canvas.width / 2;
              const centerY = canvas.height / 2;
              const radius = centerX;
  
              ctx.beginPath();
              ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
              ctx.fillStyle = color;
              ctx.fill();

              // åˆ›å»º Three.js çº¹ç†
              const texture = new THREE.CanvasTexture(canvas);
              texture.needsUpdate = true;

              // åˆå¹¶é»˜è®¤æè´¨é…ç½®å’Œç”¨æˆ·è‡ªå®šä¹‰é…ç½®
              const mergedOptions = {
                map: texture,            // åº”ç”¨åœ†å½¢çº¹ç†
                transparent: true,       // å¯ç”¨é€æ˜
                alphaTest: 0.5,          // é€æ˜åº¦é˜ˆå€¼
                size: 0.1,                // é»˜è®¤ç‚¹å°ºå¯¸
                ...materialOptions       // åˆå¹¶ç”¨æˆ·é…ç½®
              };

              return new THREE.PointsMaterial(mergedOptions);
            }
      
            const material = createCircularMaterial({
              color: SPECTRAL_COLOR['default'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialO = createCircularMaterial({
              color: SPECTRAL_COLOR['O'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialB = createCircularMaterial({
              color: SPECTRAL_COLOR['B'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialA = createCircularMaterial({
              color: SPECTRAL_COLOR['A'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialF = createCircularMaterial({
              color: SPECTRAL_COLOR['F'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialG = createCircularMaterial({
              color: SPECTRAL_COLOR['G'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialK = createCircularMaterial({
              color: SPECTRAL_COLOR['K'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });
            const materialM = createCircularMaterial({
              color: SPECTRAL_COLOR['M'],
              materialOptions: {
                size: 200 / Math.pow(camera.fov, 1.5)
              }
            });

            const materials = [materialO, materialB, materialA, materialF, materialG, materialK, materialM, material];

            // åˆ›å»º Points å¯¹è±¡å¹¶æ·»åŠ åˆ°åœºæ™¯
            materials.forEach((material, i) => {
              const points = new THREE.Points(geometries[i], material);
              scene.add(points);
            });

// ä¸ºæ¯ä¸ªæè´¨ç»„ç”Ÿæˆæ ‡æ³¨
let index = 0;
geometries.forEach((geometry, materialIndex) => {
  const positions = geometry.getAttribute('position').array;
  for (let i = 0; i < positions.length / 3; i++) {
    const x = positions[3*i];
    const y = positions[3*i + 1];
    const z = positions[3*i + 2];
    const textContent = names[index][i]||'';

    // åˆ›å»ºCSSæ–‡å­—å¯¹è±¡
    const div = document.createElement('div');
    div.className = 'csslabel';
    div.textContent = textContent;
    const cssObject = new THREE.CSS3DObject(div);
    cssObject.position.set(x, y, z);
    cssObject.scale.set(0.02,0.02,1);//ç¼©æ”¾æ ‡ç­¾å°ºå¯¸
    cssObject.name = 'csslabel';
    cssObject.position.x += 0.05;
    parent.add(cssObject); // åŒæ­¥ä½ç½®
    cssScene.add(cssObject);
  }
  index++;
});

            // æ‘„åƒæœºåˆå§‹ä½ç½®
            if (!document.getElementById('posX').value) {
                camera.position.set(DIST_LIMIT+1.1*calculateDistance(camera.fov, DIST_LIMIT), 0, 0);
            } else {
                camera.position.set(document.getElementById('posX').value||0, document.getElementById('posY').value||0, document.getElementById('posZ').value||0);
            }
            document.getElementById('posX').value = camera.position.x;
            document.getElementById('posY').value = camera.position.y;
            document.getElementById('posZ').value = camera.position.z;
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1);
            
            // è½¨é“æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', updateProjections);
        }

        // 2DæŠ•å½±è®¾ç½®
        function setupProjectionCanvases() {
            ['xy', 'xz', 'yz'].forEach(plane => {
                const canvas = document.getElementById(`${plane}-projection`);
                const ctx = canvas.getContext('2d');
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶å¯¹è§’çº¿
                // 1. è®¾ç½®çº¿æ¡å±æ€§
                ctx.lineWidth = 1;            // çº¿å®½
                ctx.strokeStyle = 'green';     // é¢œè‰²
                ctx.setLineDash([5, 5]);      // è™šçº¿æ ·å¼ï¼ˆ5åƒç´ çº¿æ®µ + 5åƒç´ é—´éš™ï¼‰

                // 2. ç»˜åˆ¶å¯¹è§’çº¿ï¼ˆä»å·¦ä¸Šåˆ°å³ä¸‹ï¼‰
                ctx.beginPath();              // å¼€å§‹æ–°è·¯å¾„
                ctx.moveTo(0, 0);            // èµ·ç‚¹ï¼ˆå·¦ä¸Šè§’ï¼‰
                ctx.lineTo(canvas.width, canvas.height); // ç»ˆç‚¹ï¼ˆå³ä¸‹è§’ï¼‰
                ctx.stroke();                 // ç»˜åˆ¶è·¯å¾„

                // 3. ç»˜åˆ¶å¦ä¸€æ¡å¯¹è§’çº¿ï¼ˆä»å·¦ä¸‹åˆ°å³ä¸Šï¼‰
                ctx.beginPath();
                ctx.moveTo(0, canvas.height); // èµ·ç‚¹ï¼ˆå·¦ä¸‹è§’ï¼‰
                ctx.lineTo(canvas.width, 0);  // ç»ˆç‚¹ï¼ˆå³ä¸Šè§’ï¼‰
                ctx.stroke();

                // ç»˜åˆ¶Limitæ–¹æ¡†
                // 1. è®¡ç®—æ–¹æ¡†å°ºå¯¸å’Œä½ç½®
                const containerWidth = canvas.width;
                const containerHeight = canvas.height;
                const boxWidth = containerWidth * 10 / 11;     // 10/11çš„å®¹å™¨å®½åº¦
                const boxHeight = containerHeight * 10 / 11;   // 10/11çš„å®¹å™¨é«˜åº¦
                const centerX = (containerWidth - boxWidth) / 2;  // æ°´å¹³å±…ä¸­
                const centerY = (containerHeight - boxHeight) / 2; // å‚ç›´å±…ä¸­

                // 2. è®¾ç½®çº¿æ¡æ ·å¼
                ctx.lineWidth = 1;         // çº¿å®½
                ctx.strokeStyle = 'green'; // é¢œè‰²
                ctx.setLineDash([5, 5]);   // è™šçº¿æ ·å¼ï¼ˆ4åƒç´ çº¿æ®µ + 4åƒç´ é—´éš™ï¼‰

                // 3. ç»˜åˆ¶è™šçº¿çŸ©å½¢
                ctx.beginPath();
                ctx.rect(
                    centerX,          // å·¦ä¸Šè§’xåæ ‡
                    centerY,          // å·¦ä¸Šè§’yåæ ‡
                    boxWidth,         // å®½åº¦
                    boxHeight         // é«˜åº¦
                );
                ctx.stroke();           // ç»˜åˆ¶è·¯å¾„
                
                // ç»˜åˆ¶æŠ•å½±
                data.forEach(d => {
                    const x = mapToCanvas(d[plane[0]], ranges[plane[0]], canvas.width);
                    const y = mapToCanvas(d[plane[1]], ranges[plane[1]], canvas.height);
                    
                    ctx.fillStyle = SPECTRAL_COLOR[d.spect]||SPECTRAL_COLOR['default'];
                    ctx.beginPath();
                    ctx.arc(x, canvas.height - y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                    //ctx.fillRect(x, canvas.height - y, 1, 1); // åè½¬XYè½´
                });
            });
        }

        // åæ ‡æ˜ å°„
        function mapToCanvas(value, range, canvasSize) {
            //return ((value - range.min) / (range.max - range.min)) * canvasSize;
            return ((value + 1.1*DIST_LIMIT) / (2.2*DIST_LIMIT)) * canvasSize;
        }

        // æ›´æ–°æŠ•å½±
        function updateProjections() {
            ['xy', 'xz', 'yz'].forEach(plane => {
                const canvas = document.getElementById(`${plane}-projection`);
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶å¯¹è§’çº¿
                // 1. è®¾ç½®çº¿æ¡å±æ€§
                ctx.lineWidth = 1;            // çº¿å®½
                ctx.strokeStyle = 'green';     // é¢œè‰²
                ctx.setLineDash([5, 5]);      // è™šçº¿æ ·å¼ï¼ˆ5åƒç´ çº¿æ®µ + 5åƒç´ é—´éš™ï¼‰

                // 2. ç»˜åˆ¶å¯¹è§’çº¿ï¼ˆä»å·¦ä¸Šåˆ°å³ä¸‹ï¼‰
                ctx.beginPath();              // å¼€å§‹æ–°è·¯å¾„
                ctx.moveTo(0, 0);            // èµ·ç‚¹ï¼ˆå·¦ä¸Šè§’ï¼‰
                ctx.lineTo(canvas.width, canvas.height); // ç»ˆç‚¹ï¼ˆå³ä¸‹è§’ï¼‰
                ctx.stroke();                 // ç»˜åˆ¶è·¯å¾„

                // 3. ç»˜åˆ¶å¦ä¸€æ¡å¯¹è§’çº¿ï¼ˆä»å·¦ä¸‹åˆ°å³ä¸Šï¼‰
                ctx.beginPath();
                ctx.moveTo(0, canvas.height); // èµ·ç‚¹ï¼ˆå·¦ä¸‹è§’ï¼‰
                ctx.lineTo(canvas.width, 0);  // ç»ˆç‚¹ï¼ˆå³ä¸Šè§’ï¼‰
                ctx.stroke();

                // ç»˜åˆ¶Limitæ–¹æ¡†
                // 1. è®¡ç®—æ–¹æ¡†å°ºå¯¸å’Œä½ç½®
                const containerWidth = canvas.width;
                const containerHeight = canvas.height;
                const boxWidth = containerWidth * 10 / 11;     // 10/11çš„å®¹å™¨å®½åº¦
                const boxHeight = containerHeight * 10 / 11;   // 10/11çš„å®¹å™¨é«˜åº¦
                const centerX = (containerWidth - boxWidth) / 2;  // æ°´å¹³å±…ä¸­
                const centerY = (containerHeight - boxHeight) / 2; // å‚ç›´å±…ä¸­

                // 2. è®¾ç½®çº¿æ¡æ ·å¼
                ctx.lineWidth = 1;         // çº¿å®½
                ctx.strokeStyle = 'green'; // é¢œè‰²
                ctx.setLineDash([4, 4]);   // è™šçº¿æ ·å¼ï¼ˆ4åƒç´ çº¿æ®µ + 4åƒç´ é—´éš™ï¼‰

                // 3. ç»˜åˆ¶è™šçº¿çŸ©å½¢
                ctx.beginPath();
                ctx.rect(
                    centerX,          // å·¦ä¸Šè§’xåæ ‡
                    centerY,          // å·¦ä¸Šè§’yåæ ‡
                    boxWidth,         // å®½åº¦
                    boxHeight         // é«˜åº¦
                );
                ctx.stroke();           // ç»˜åˆ¶è·¯å¾„
                
                // ç»˜åˆ¶æŠ•å½±
                data.forEach(d => {
                    const x = mapToCanvas(d[plane[0]], ranges[plane[0]], canvas.width);
                    const y = mapToCanvas(d[plane[1]], ranges[plane[1]], canvas.height);
                    
                    ctx.fillStyle = SPECTRAL_COLOR[d.spect]||SPECTRAL_COLOR['default'];
                    ctx.beginPath();
                    ctx.arc(x, canvas.height - y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                    //ctx.fillRect(x, canvas.height - y, 1, 1); // åè½¬XYè½´
                });
            });
        }

        // äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            // æ‘„åƒæœºä½ç½®æ§åˆ¶
            ['posX', 'posY', 'posZ', 'Fov', 'Dist', 'cenX', 'cenY', 'cenZ'].forEach(id => {
                document.getElementById(id).addEventListener('change', e => {
                    DIST_LIMIT = parseFloat(document.getElementById('Dist').value) || 4;
                    if (id==="Dist" || id==='cenX' || id==='cenY' || id==='cenZ') {
                        loadCSVData();
                    }
                    setupThreeScene();
                    camera.fov = parseFloat(document.getElementById('Fov').value) || 90;
                    camera.updateProjectionMatrix();
                    updateProjections();
                    controls.update();
                });
            });
        }

        function onWindowResize() {
            camera.aspect = 1;
            camera.updateProjectionMatrix();
            renderer.setSize(Math.min(window.innerWidth, window.innerHeight), Math.min(window.innerWidth, window.innerHeight));
            cssRenderer.setSize(Math.min(window.innerWidth, window.innerHeight), Math.min(window.innerWidth, window.innerHeight));
            //setupThreeScene();
        }

        function resetCamera() {
            camera.position.set(DIST_LIMIT+1.1*calculateDistance(camera.fov, DIST_LIMIT), 0, 0);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1);
            document.getElementById('posX').value = camera.position.x.toFixed(0);
            document.getElementById('posY').value = camera.position.y.toFixed(0);
            document.getElementById('posZ').value = camera.position.z.toFixed(0);
            document.getElementById('Fov').value = camera.fov;
            document.getElementById('Dist').value = DIST_LIMIT;
            controls.update();
        }

function updateLabel(name) {
    const cameraPosition = camera.position.clone();
    const cameraForward = camera.getWorldDirection(new THREE.Vector3()).clone(); // æ‘„åƒæœºçš„å‰å‘æ–¹å‘ï¼ˆæœå‘ç›®æ ‡ï¼‰
    const cameraUp = camera.up.clone(); // æ‘„åƒæœºçš„ä¸Šæ–¹å‘
    const nodes = [];

    // æ”¶é›†ç›®æ ‡èŠ‚ç‚¹
    cssScene.children.forEach(node => {
        if (node.name === name) {
            nodes.push(node);
        }
    });

    // éå†èŠ‚ç‚¹å¹¶è°ƒæ•´æ—‹è½¬å’Œä½ç½®
    nodes.forEach(node => {
        // åˆå§‹åŒ–åŸå§‹ä½ç½®ï¼ˆä»…ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æ‰§è¡Œï¼‰
        if (!node.originalPosition) {
            node.originalPosition = node.position.clone(); // ä¿å­˜åˆå§‹ä½ç½®
        }

        // ğŸ“Œ å…³é”®ä¿®æ”¹ï¼šå¼ºåˆ¶æ ‡ç­¾å¹³é¢å¹³è¡Œäºæ‘„åƒæœºè§†é‡å¹³é¢
        // 1. è®¾ç½®æ ‡ç­¾çš„ä¸Šæ–¹å‘ä¸ºæ‘„åƒæœºçš„ä¸Šæ–¹å‘
        node.up.copy(cameraUp);

        // 2. è®¡ç®—æ ‡ç­¾çš„æ­£é¢æ–¹å‘ä¸ºæ‘„åƒæœºçš„å‰å‘æ–¹å‘ï¼ˆå³æ ‡ç­¾å¹³é¢ä¸æ‘„åƒæœºå¹³é¢å¹³è¡Œï¼‰
        const desiredForward = cameraForward.clone().negate(); // æ ‡ç­¾æ­£é¢æœå‘æ‘„åƒæœºï¼ˆä¸æ‘„åƒæœºå‰å‘ç›¸åï¼‰

        // 3. æ„å»ºæ­£ç¡®çš„æ—‹è½¬çŸ©é˜µï¼ˆç¡®ä¿æ ‡ç­¾å¹³é¢ä¸æ‘„åƒæœºå¹³é¢å¹³è¡Œï¼‰
        const rotationMatrix = new THREE.Matrix4();
        rotationMatrix.lookAt(
            node.position.clone().add(desiredForward), // ç›®æ ‡ç‚¹ï¼ˆæ²¿ desiredForward æ–¹å‘ï¼‰
            node.position, // å½“å‰æ ‡ç­¾ä½ç½®ï¼ˆeyeï¼‰
            cameraUp // ä¸Šæ–¹å‘
        );

        // æå–æ—‹è½¬å››å…ƒæ•°
        const rotation = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
        node.quaternion.copy(rotation);

        // åº”ç”¨å‘ä¸‹åç§»ï¼ˆé¿å…é®æŒ¡ç›®æ ‡ï¼‰
        const offsetDistance = 0.2; // å¯è°ƒæ•´åç§»è·ç¦»
        const direction = cameraUp.clone().multiplyScalar(-offsetDistance); // æ²¿æ‘„åƒæœºçš„ä¸Šæ–¹å‘åæ–¹å‘ï¼ˆå‘ä¸‹ï¼‰
        node.position.copy(node.originalPosition).add(direction); // åŸºäºåŸå§‹ä½ç½®åç§»
    });
}

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            cssRenderer.render(cssScene, camera);
            updateLabel("csslabel") // labelæœå‘camera
        }

        init();
    </script>
</body>
</html>
